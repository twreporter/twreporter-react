import { ChunkExtractor } from '@loadable/server'
import { ServerStyleSheet, StyleSheetManager } from 'styled-components'
import { StaticRouter } from 'react-router-dom'
import App from '../../app'
import get from 'lodash/get'
import Html from '../../html'
import React from 'react'
import { renderToString } from 'react-dom/server'
import { HelmetProvider } from 'react-helmet-async'
import requestOrigins from '@twreporter/core/lib/constants/request-origins'
import twreporterRedux from '@twreporter/redux'

const _ = {
  get,
}

/**
 *  This middleware composes html static markup according to redux store.
 *  It updates router context into `req[namespace].routerStaticContext`
 *  and html markup string into `req[namespace].html`.
 *
 *  @param {string} namespace - namespace is used in `req` object to avoid from overwriting the existed field
 *  @param {Object} webpackAssets - webpack assets defined in webpack-assets.json
 *  @param {Object} webpackAssets.javascripts
 *  @param {string} webpackAssets.javascripts.main
 *  @param {[]string} webpackAssets.stylesheets
 *  @param {Object} loadableStats - JSON file generated by @loadable/webpack-plugin plugin
 *  @param {Object} options
 *  @param {string} options.releaseBranch - release branch, it could be 'master', 'test', 'staging' or 'release'
 */
function renderHTMLMiddleware(
  namespace,
  webpackAssets,
  loadableStats,
  options
) {
  return function middleware(req, res, next) {
    const storeForClientSideRendering = _.get(req, [namespace, 'reduxStore'])
    if (!storeForClientSideRendering) {
      next(new Error(`req.${namespace}.reduxStore is not existed`))
      return
    }
    // The redux actions will take the `origins` in the store, and use them as the origins of request url.
    // The initial origins are for server side renedering. So we need to set them for client side rendering before we send the store to client.
    storeForClientSideRendering.dispatch({
      type: twreporterRedux.actionTypes.origins.update,
      payload: requestOrigins.forClientSideRendering[options.releaseBranch],
    })
    const routerStaticContext = {}
    const sheet = new ServerStyleSheet()
    const helmetContext = {}
    // get loadable chunk
    // `loadable-state.json` is created by `@lodable/webpack-plugin`
    const extractor = new ChunkExtractor({ stats: loadableStats })
    const contentMarkup = renderToString(
      extractor.collectChunks(
        <StyleSheetManager sheet={sheet.instance}>
          <StaticRouter location={req.url} context={routerStaticContext}>
            <HelmetProvider context={helmetContext}>
              <App
                reduxStore={storeForClientSideRendering}
                releaseBranch={options.releaseBranch}
              />
            </HelmetProvider>
          </StaticRouter>
        </StyleSheetManager>
      )
    )

    const scripts = [
      webpackAssets.javascripts.manifest,
      ...webpackAssets.javascripts.vendors,
    ]
    // main bundle should be last
    scripts.push(webpackAssets.javascripts.main)

    const { helmet } = helmetContext
    const html = renderToString(
      <Html
        contentMarkup={contentMarkup}
        store={storeForClientSideRendering}
        scripts={scripts}
        scriptElement={extractor.getScriptElements()}
        styles={webpackAssets.stylesheets}
        styleElement={sheet.getStyleElement()}
        helmet={helmet}
      />
    )

    req[namespace].routerStaticContext = routerStaticContext
    req[namespace].html = `<!doctype html>${html}`

    next()
  }
}

export default renderHTMLMiddleware
