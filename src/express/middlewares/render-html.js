import { getBundles } from 'react-loadable/webpack'
import { ServerStyleSheet, StyleSheetManager } from 'styled-components'
import { StaticRouter } from 'react-router-dom'
import App from '../../app'
import get from 'lodash/get'
import Html from '../../html'
import Loadable from 'react-loadable'
import React from 'react'
import ReactDOMServer from 'react-dom/server'
import requestOrigins from '@twreporter/core/lib/constants/request-origins'
import twreporterRedux from '@twreporter/redux'

const _ = {
  get,
}

/**
 *  This middleware composes html static markup according to redux store.
 *  It updates router context into `req[namespace].routerStaticContext`
 *  and html markup string into `req[namespace].html`.
 *
 *  @param {string} namespace - namespace is used in `req` object to avoid from overwriting the existed field
 *  @param {Object} webpackAssets - webpack assets defined in webpack-assets.json
 *  @param {Object} webpackAssets.javascripts
 *  @param {string} webpackAssets.javascripts.main
 *  @param {[]string} webpackAssets.stylesheets
 *  @param {Object} loadableStats - JSON file generated by react-loadable/webpack plugin
 *  @param {Object} options
 *  @param {string} options.releaseBranch - release branch, it could be 'master', 'test', 'staging' or 'release'
 */
function renderHTMLMiddleware(
  namespace,
  webpackAssets,
  loadableStats,
  options
) {
  return function middleware(req, res, next) {
    const modules = []
    const storeForClientSideRendering = _.get(req, [namespace, 'reduxStore'])
    if (!storeForClientSideRendering) {
      next(new Error(`req.${namespace}.reduxStore is not existed`))
      return
    }
    // The redux actions will take the `origins` in the store, and use them as the origins of request url.
    // The initial origins are for server side renedering. So we need to set them for client side rendering before we send the store to client.
    storeForClientSideRendering.dispatch({
      type: twreporterRedux.actionTypes.origins.update,
      payload: requestOrigins.forClientSideRendering[options.releaseBranch],
    })
    const routerStaticContext = {}
    const sheet = new ServerStyleSheet()
    const contentMarkup = ReactDOMServer.renderToString(
      <StyleSheetManager sheet={sheet.instance}>
        <StaticRouter location={req.url} context={routerStaticContext}>
          <Loadable.Capture report={moduleName => modules.push(moduleName)}>
            <App
              reduxStore={storeForClientSideRendering}
              releaseBranch={options.releaseBranch}
            />
          </Loadable.Capture>
        </StaticRouter>
      </StyleSheetManager>
    )

    const bundles = getBundles(loadableStats, modules)

    const scripts = [
      webpackAssets.javascripts.manifest,
      ...webpackAssets.javascripts.vendors,
    ]
    bundles.forEach(bundle => {
      scripts.push(_.get(bundle, 'publicPath', ''))
    })
    // main bundle should be last
    scripts.push(webpackAssets.javascripts.main)

    const html = ReactDOMServer.renderToString(
      <Html
        contentMarkup={contentMarkup}
        store={storeForClientSideRendering}
        scripts={scripts}
        styles={webpackAssets.stylesheets}
        styleElement={sheet.getStyleElement()}
      />
    )

    req[namespace].routerStaticContext = routerStaticContext
    req[namespace].html = `<!doctype html>${html}`

    next()
  }
}

export default renderHTMLMiddleware
